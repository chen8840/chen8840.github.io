### rust里的内存对齐

内存对齐主要遵循下面三个原则:

1. 结构体变量的起始地址能够被其最宽的成员大小整除
2. 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节
3. 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字

上代码

```rust
struct A {
  a: u8,
  b: u32,
  c: u16,
  d: u8,
  e: u8,
}

fn main() {
  let a = A{a:1,b:1,c:1,d:1,e:1};
  println!("{:?}", std::mem::size_of::<A>());
  println!("{:p}", &a);
  println!("{:p}", &a.a);
  println!("{:p}", &a.b);
  println!("{:p}", &a.c);
  println!("{:p}", &a.d);
  println!("{:p}", &a.e);
}
```

按一般理解，A的内存图应该是

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| a	| x |	x |	x	| b	| b	| b	| b	| c	| c	| d	| e	| x	| x |

总字节数应该是14

但是输出为

12
0x18e94ff788
0x18e94ff78e
0x18e94ff788
0x18e94ff78c
0x18e94ff78f
0x18e94ff790

可以发现rust编译器将a,b,c,d,e的位置调换了

内存图如下

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| b	| b	| b	| b	| c	| c	| a	| d	| e	| x	| x	| x |
